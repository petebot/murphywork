import "./chunk-AYNHEKRI.js";
import {
  SvelteComponentDev,
  add_location,
  attr_dev,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_text,
  construct_svelte_component_dev,
  create_component,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  get_all_dirty_from_scope,
  get_slot_changes,
  group_outros,
  init,
  insert_hydration_dev,
  mount_component,
  noop,
  outro_and_destroy_block,
  safe_not_equal,
  set_data_dev,
  set_style,
  text,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_dynamic_element,
  validate_each_keys,
  validate_slots,
  validate_void_dynamic_element
} from "./chunk-DMVB5VYH.js";
import "./chunk-2GBBIY5G.js";
import "./chunk-TKZWA4SW.js";

// node_modules/@portabletext/toolkit/dist/index.js
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function isPortableTextSpan(node) {
  return node._type === "span" && "text" in node && typeof node.text == "string" && (typeof node.marks > "u" || Array.isArray(node.marks) && node.marks.every((mark) => typeof mark == "string"));
}
function isPortableTextBlock(node) {
  return (
    // A block doesn't _have_ to be named 'block' - to differentiate between
    // allowed child types and marks, one might name them differently
    typeof node._type == "string" && // Toolkit-types like nested spans are @-prefixed
    node._type[0] !== "@" && // `markDefs` isn't _required_ per say, but if it's there, it needs to be an array
    (!("markDefs" in node) || !node.markDefs || Array.isArray(node.markDefs) && // Every mark definition needs to have an `_key` to be mappable in child spans
    node.markDefs.every((def) => typeof def._key == "string")) && // `children` is required and needs to be an array
    "children" in node && Array.isArray(node.children) && // All children are objects with `_type` (usually spans, but can contain other stuff)
    node.children.every((child) => typeof child == "object" && "_type" in child)
  );
}
function isPortableTextListItemBlock(block) {
  return isPortableTextBlock(block) && "listItem" in block && typeof block.listItem == "string" && (typeof block.level > "u" || typeof block.level == "number");
}
function isPortableTextToolkitList(block) {
  return block._type === "@list";
}
function isPortableTextToolkitSpan(span) {
  return span._type === "@span";
}
function isPortableTextToolkitTextNode(node) {
  return node._type === "@text";
}
var knownDecorators = ["strong", "em", "code", "underline", "strike-through"];
function sortMarksByOccurences(span, index, blockChildren) {
  if (!isPortableTextSpan(span) || !span.marks) return [];
  if (!span.marks.length) return [];
  const marks = span.marks.slice(), occurences = {};
  return marks.forEach((mark) => {
    occurences[mark] = 1;
    for (let siblingIndex = index + 1; siblingIndex < blockChildren.length; siblingIndex++) {
      const sibling = blockChildren[siblingIndex];
      if (sibling && isPortableTextSpan(sibling) && Array.isArray(sibling.marks) && sibling.marks.indexOf(mark) !== -1) occurences[mark]++;
      else break;
    }
  }), marks.sort((markA, markB) => sortMarks(occurences, markA, markB));
}
function sortMarks(occurences, markA, markB) {
  const aOccurences = occurences[markA], bOccurences = occurences[markB];
  if (aOccurences !== bOccurences) return bOccurences - aOccurences;
  const aKnownPos = knownDecorators.indexOf(markA), bKnownPos = knownDecorators.indexOf(markB);
  return aKnownPos !== bKnownPos ? aKnownPos - bKnownPos : markA.localeCompare(markB);
}
function buildMarksTree(block) {
  var _a;
  const {
    children: children2,
    markDefs = []
  } = block;
  if (!children2 || !children2.length) return [];
  const sortedMarks = children2.map(sortMarksByOccurences), rootNode = {
    _type: "@span",
    children: [],
    markType: "<unknown>"
  };
  let nodeStack = [rootNode];
  for (let i = 0; i < children2.length; i++) {
    const span = children2[i];
    if (!span) continue;
    const marksNeeded = sortedMarks[i] || [];
    let pos = 1;
    if (nodeStack.length > 1) for (pos; pos < nodeStack.length; pos++) {
      const mark = ((_a = nodeStack[pos]) == null ? void 0 : _a.markKey) || "", index = marksNeeded.indexOf(mark);
      if (index === -1) break;
      marksNeeded.splice(index, 1);
    }
    nodeStack = nodeStack.slice(0, pos);
    let currentNode = nodeStack[nodeStack.length - 1];
    if (currentNode) {
      for (const markKey of marksNeeded) {
        const markDef = markDefs.find((def) => def._key === markKey), markType = markDef ? markDef._type : markKey, node = {
          _type: "@span",
          _key: span._key,
          children: [],
          markDef,
          markType,
          markKey
        };
        currentNode.children.push(node), nodeStack.push(node), currentNode = node;
      }
      if (isPortableTextSpan(span)) {
        const lines = span.text.split(`
`);
        for (let line = lines.length; line-- > 1; ) lines.splice(line, 0, `
`);
        currentNode.children = currentNode.children.concat(lines.map((text2) => ({
          _type: "@text",
          text: text2
        })));
      } else currentNode.children = currentNode.children.concat(span);
    }
  }
  return rootNode.children;
}
function nestLists(blocks, mode) {
  const tree = [];
  let currentList;
  for (let i = 0; i < blocks.length; i++) {
    const block = blocks[i];
    if (block) {
      if (!isPortableTextListItemBlock(block)) {
        tree.push(block), currentList = void 0;
        continue;
      }
      if (!currentList) {
        currentList = listFromBlock(block, i, mode), tree.push(currentList);
        continue;
      }
      if (blockMatchesList(block, currentList)) {
        currentList.children.push(block);
        continue;
      }
      if ((block.level || 1) > currentList.level) {
        const newList = listFromBlock(block, i, mode);
        if (mode === "html") {
          const lastListItem = currentList.children[currentList.children.length - 1], newLastChild = _objectSpread(_objectSpread({}, lastListItem), {}, {
            children: [...lastListItem.children, newList]
          });
          currentList.children[currentList.children.length - 1] = newLastChild;
        } else currentList.children.push(newList);
        currentList = newList;
        continue;
      }
      if ((block.level || 1) < currentList.level) {
        const matchingBranch = tree[tree.length - 1], match = matchingBranch && findListMatching(matchingBranch, block);
        if (match) {
          currentList = match, currentList.children.push(block);
          continue;
        }
        currentList = listFromBlock(block, i, mode), tree.push(currentList);
        continue;
      }
      if (block.listItem !== currentList.listItem) {
        const matchingBranch = tree[tree.length - 1], match = matchingBranch && findListMatching(matchingBranch, {
          level: block.level || 1
        });
        if (match && match.listItem === block.listItem) {
          currentList = match, currentList.children.push(block);
          continue;
        } else {
          currentList = listFromBlock(block, i, mode), tree.push(currentList);
          continue;
        }
      }
      console.warn("Unknown state encountered for block", block), tree.push(block);
    }
  }
  return tree;
}
function blockMatchesList(block, list) {
  return (block.level || 1) === list.level && block.listItem === list.listItem;
}
function listFromBlock(block, index, mode) {
  return {
    _type: "@list",
    _key: `${block._key || `${index}`}-parent`,
    mode,
    level: block.level || 1,
    listItem: block.listItem,
    children: [block]
  };
}
function findListMatching(rootNode, matching) {
  const level = matching.level || 1, style = matching.listItem || "normal", filterOnType = typeof matching.listItem == "string";
  if (isPortableTextToolkitList(rootNode) && (rootNode.level || 1) === level && filterOnType && (rootNode.listItem || "normal") === style) return rootNode;
  if (!("children" in rootNode)) return;
  const node = rootNode.children[rootNode.children.length - 1];
  return node && !isPortableTextSpan(node) ? findListMatching(node, matching) : void 0;
}
function spanToPlainText(span) {
  let text2 = "";
  return span.children.forEach((current) => {
    isPortableTextToolkitTextNode(current) ? text2 += current.text : isPortableTextToolkitSpan(current) && (text2 += spanToPlainText(current));
  }), text2;
}
var leadingSpace = /^\s/;
var trailingSpace = /^\s/;
function toPlainText(block) {
  const blocks = Array.isArray(block) ? block : [block];
  let text2 = "";
  return blocks.forEach((current, index) => {
    if (!isPortableTextBlock(current)) return;
    let pad = false;
    current.children.forEach((span) => {
      isPortableTextSpan(span) ? (text2 += pad && text2 && !trailingSpace.test(text2) && !leadingSpace.test(span.text) ? " " : "", text2 += span.text, pad = false) : pad = true;
    }), index !== blocks.length - 1 && (text2 += `

`);
  }), text2;
}
var LIST_NEST_MODE_HTML = "html";

// node_modules/@portabletext/svelte/dist/assertBlockKey.js
function getRandomKey() {
  return Math.random().toFixed(5).split(".")[1];
}
function assertSpanKey(span) {
  return {
    _key: span._key || getRandomKey(),
    ...span
  };
}
function assertBlockKey(block) {
  return {
    _key: block._key || getRandomKey(),
    ...block,
    ...block._type === "block" && Array.isArray(block.children) ? {
      children: block.children.map(assertSpanKey)
    } : {}
  };
}

// node_modules/@portabletext/svelte/dist/defaultComponents/DefaultMark.svelte
var file = "node_modules/@portabletext/svelte/dist/defaultComponents/DefaultMark.svelte";
function create_else_block(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(26:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let del;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      del = element("del");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      del = claim_element(nodes, "DEL", {});
      var del_nodes = children(del);
      if (default_slot) default_slot.l(del_nodes);
      del_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(del, file, 22, 2, 410);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, del, anchor);
      if (default_slot) {
        default_slot.m(del, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(del);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(22:40) ",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let span;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { style: true });
      var span_nodes = children(span);
      if (default_slot) default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_style(span, "text-decoration", "underline");
      add_location(span, file, 18, 2, 302);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(18:35) ",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let code;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      code = element("code");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      code = claim_element(nodes, "CODE", {});
      var code_nodes = children(code);
      if (default_slot) default_slot.l(code_nodes);
      code_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(code, file, 14, 2, 234);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, code, anchor);
      if (default_slot) {
        default_slot.m(code, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(code);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(14:30) ",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let em;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      em = element("em");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      em = claim_element(nodes, "EM", {});
      var em_nodes = children(em);
      if (default_slot) default_slot.l(em_nodes);
      em_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(em, file, 10, 2, 175);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, em, anchor);
      if (default_slot) {
        default_slot.m(em, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(em);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(10:28) ",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let strong;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      strong = element("strong");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      strong = claim_element(nodes, "STRONG", {});
      var strong_nodes = children(strong);
      if (default_slot) default_slot.l(strong_nodes);
      strong_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(strong, file, 6, 2, 110);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, strong, anchor);
      if (default_slot) {
        default_slot.m(strong, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(strong);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(6:0) {#if markType === 'strong'}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block,
    create_if_block_1,
    create_if_block_2,
    create_if_block_3,
    create_if_block_4,
    create_else_block
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*markType*/
      ctx2[0] === "strong"
    ) return 0;
    if (
      /*markType*/
      ctx2[0] === "em"
    ) return 1;
    if (
      /*markType*/
      ctx2[0] === "code"
    ) return 2;
    if (
      /*markType*/
      ctx2[0] === "underline"
    ) return 3;
    if (
      /*markType*/
      ctx2[0] === "strike-through"
    ) return 4;
    return 5;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let markType;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DefaultMark", slots, ["default"]);
  let { portableText } = $$props;
  $$self.$$.on_mount.push(function() {
    if (portableText === void 0 && !("portableText" in $$props || $$self.$$.bound[$$self.$$.props["portableText"]])) {
      console.warn("<DefaultMark> was created without expected prop 'portableText'");
    }
  });
  const writable_props = ["portableText"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<DefaultMark> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("portableText" in $$props2) $$invalidate(1, portableText = $$props2.portableText);
    if ("$$scope" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ portableText, markType });
  $$self.$inject_state = ($$props2) => {
    if ("portableText" in $$props2) $$invalidate(1, portableText = $$props2.portableText);
    if ("markType" in $$props2) $$invalidate(0, markType = $$props2.markType);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*portableText*/
    2) {
      $: $$invalidate(0, { markType } = portableText, markType);
    }
  };
  return [markType, portableText, $$scope, slots];
}
var DefaultMark = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { portableText: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DefaultMark",
      options,
      id: create_fragment.name
    });
  }
  get portableText() {
    throw new Error("<DefaultMark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set portableText(value) {
    throw new Error("<DefaultMark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DefaultMark_default = DefaultMark;

// node_modules/@portabletext/svelte/dist/defaultComponents/DefaultLink.svelte
var file2 = "node_modules/@portabletext/svelte/dist/defaultComponents/DefaultLink.svelte";
function create_else_block2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(10:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let a;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const block = {
    c: function create() {
      a = element("a");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", { href: true });
      var a_nodes = children(a);
      if (default_slot) default_slot.l(a_nodes);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        a,
        "href",
        /*href*/
        ctx[0]
      );
      add_location(a, file2, 8, 2, 180);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      if (default_slot) {
        default_slot.m(a, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*href*/
      1) {
        attr_dev(
          a,
          "href",
          /*href*/
          ctx2[0]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(a);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(8:0) {#if typeof href === 'string'}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block2, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (typeof /*href*/
    ctx2[0] === "string") return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let value;
  let href;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DefaultLink", slots, ["default"]);
  let { portableText } = $$props;
  $$self.$$.on_mount.push(function() {
    if (portableText === void 0 && !("portableText" in $$props || $$self.$$.bound[$$self.$$.props["portableText"]])) {
      console.warn("<DefaultLink> was created without expected prop 'portableText'");
    }
  });
  const writable_props = ["portableText"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<DefaultLink> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("portableText" in $$props2) $$invalidate(1, portableText = $$props2.portableText);
    if ("$$scope" in $$props2) $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ portableText, value, href });
  $$self.$inject_state = ($$props2) => {
    if ("portableText" in $$props2) $$invalidate(1, portableText = $$props2.portableText);
    if ("value" in $$props2) $$invalidate(2, value = $$props2.value);
    if ("href" in $$props2) $$invalidate(0, href = $$props2.href);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*portableText*/
    2) {
      $: $$invalidate(2, { value } = portableText, value);
    }
    if ($$self.$$.dirty & /*value*/
    4) {
      $: $$invalidate(0, href = (value == null ? void 0 : value.href) || (value == null ? void 0 : value.url) || (value == null ? void 0 : value.link) || (value == null ? void 0 : value.value));
    }
  };
  return [href, portableText, value, $$scope, slots];
}
var DefaultLink = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { portableText: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DefaultLink",
      options,
      id: create_fragment2.name
    });
  }
  get portableText() {
    throw new Error("<DefaultLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set portableText(value) {
    throw new Error("<DefaultLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DefaultLink_default = DefaultLink;

// node_modules/@portabletext/svelte/dist/defaultComponents/DefaultBlock.svelte
var file3 = "node_modules/@portabletext/svelte/dist/defaultComponents/DefaultBlock.svelte";
function create_else_block3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block3.name,
    type: "else",
    source: "(12:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let p;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const block = {
    c: function create() {
      p = element("p");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      p = claim_element(nodes, "P", {});
      var p_nodes = children(p);
      if (default_slot) default_slot.l(p_nodes);
      p_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(p, file3, 10, 2, 277);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p, anchor);
      if (default_slot) {
        default_slot.m(p, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(10:29) ",
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let previous_tag = (
    /*style*/
    ctx[0]
  );
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(
    /*style*/
    ctx[0]
  );
  validate_void_dynamic_element(
    /*style*/
    ctx[0]
  );
  let svelte_element = (
    /*style*/
    ctx[0] && create_dynamic_element(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element) svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element) svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element) svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*style*/
        ctx2[0]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*style*/
          ctx2[0];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*style*/
          ctx2[0]
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*style*/
            ctx2[0]
          );
          validate_void_dynamic_element(
            /*style*/
            ctx2[0]
          );
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*style*/
          ctx2[0];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*style*/
        ctx2[0];
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(svelte_element, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element_anchor);
      }
      if (svelte_element) svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(8:0) {#if ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote'].includes(style)}",
    ctx
  });
  return block;
}
function create_dynamic_element(ctx) {
  let svelte_element;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const block = {
    c: function create() {
      svelte_element = element(
        /*style*/
        ctx[0]
      );
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*style*/
        (ctx[0] || "null").toUpperCase(),
        {}
      );
      var svelte_element_nodes = children(svelte_element);
      if (default_slot) default_slot.l(svelte_element_nodes);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(svelte_element, file3, 8, 2, 190);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element.name,
    type: "child_dynamic_element",
    source: "(9:2) <svelte:element this={style}>",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block3, create_if_block_12, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & /*style*/
    1) show_if = null;
    if (show_if == null) show_if = !!["h1", "h2", "h3", "h4", "h5", "h6", "blockquote"].includes(
      /*style*/
      ctx2[0]
    );
    if (show_if) return 0;
    if (
      /*style*/
      ctx2[0] === "normal"
    ) return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let value;
  let style;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DefaultBlock", slots, ["default"]);
  let { portableText } = $$props;
  $$self.$$.on_mount.push(function() {
    if (portableText === void 0 && !("portableText" in $$props || $$self.$$.bound[$$self.$$.props["portableText"]])) {
      console.warn("<DefaultBlock> was created without expected prop 'portableText'");
    }
  });
  const writable_props = ["portableText"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<DefaultBlock> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("portableText" in $$props2) $$invalidate(1, portableText = $$props2.portableText);
    if ("$$scope" in $$props2) $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ portableText, value, style });
  $$self.$inject_state = ($$props2) => {
    if ("portableText" in $$props2) $$invalidate(1, portableText = $$props2.portableText);
    if ("value" in $$props2) $$invalidate(2, value = $$props2.value);
    if ("style" in $$props2) $$invalidate(0, style = $$props2.style);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*portableText*/
    2) {
      $: $$invalidate(2, { value } = portableText, value);
    }
    if ($$self.$$.dirty & /*value*/
    4) {
      $: $$invalidate(0, style = value.style || "normal");
    }
  };
  return [style, portableText, value, $$scope, slots];
}
var DefaultBlock = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { portableText: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DefaultBlock",
      options,
      id: create_fragment3.name
    });
  }
  get portableText() {
    throw new Error("<DefaultBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set portableText(value) {
    throw new Error("<DefaultBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DefaultBlock_default = DefaultBlock;

// node_modules/@portabletext/svelte/dist/defaultComponents/DefaultList.svelte
var file4 = "node_modules/@portabletext/svelte/dist/defaultComponents/DefaultList.svelte";
function create_else_block4(ctx) {
  let ul;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const block = {
    c: function create() {
      ul = element("ul");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      ul = claim_element(nodes, "UL", {});
      var ul_nodes = children(ul);
      if (default_slot) default_slot.l(ul_nodes);
      ul_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(ul, file4, 10, 2, 164);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ul, anchor);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(ul);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block4.name,
    type: "else",
    source: "(10:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block4(ctx) {
  let ol;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const block = {
    c: function create() {
      ol = element("ol");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      ol = claim_element(nodes, "OL", {});
      var ol_nodes = children(ol);
      if (default_slot) default_slot.l(ol_nodes);
      ol_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(ol, file4, 8, 2, 136);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ol, anchor);
      if (default_slot) {
        default_slot.m(ol, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(ol);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(8:0) {#if listItem === 'number'}",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block4, create_else_block4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*listItem*/
      ctx2[0] === "number"
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let value;
  let listItem;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DefaultList", slots, ["default"]);
  let { portableText } = $$props;
  $$self.$$.on_mount.push(function() {
    if (portableText === void 0 && !("portableText" in $$props || $$self.$$.bound[$$self.$$.props["portableText"]])) {
      console.warn("<DefaultList> was created without expected prop 'portableText'");
    }
  });
  const writable_props = ["portableText"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<DefaultList> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("portableText" in $$props2) $$invalidate(1, portableText = $$props2.portableText);
    if ("$$scope" in $$props2) $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ portableText, value, listItem });
  $$self.$inject_state = ($$props2) => {
    if ("portableText" in $$props2) $$invalidate(1, portableText = $$props2.portableText);
    if ("value" in $$props2) $$invalidate(2, value = $$props2.value);
    if ("listItem" in $$props2) $$invalidate(0, listItem = $$props2.listItem);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*portableText*/
    2) {
      $: $$invalidate(2, { value } = portableText, value);
    }
    if ($$self.$$.dirty & /*value*/
    4) {
      $: $$invalidate(0, { listItem } = value, listItem);
    }
  };
  return [listItem, portableText, value, $$scope, slots];
}
var DefaultList = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { portableText: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DefaultList",
      options,
      id: create_fragment4.name
    });
  }
  get portableText() {
    throw new Error("<DefaultList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set portableText(value) {
    throw new Error("<DefaultList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DefaultList_default = DefaultList;

// node_modules/@portabletext/svelte/dist/defaultComponents/DefaultListItem.svelte
var file5 = "node_modules/@portabletext/svelte/dist/defaultComponents/DefaultListItem.svelte";
function create_fragment5(ctx) {
  let li;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  const block = {
    c: function create() {
      li = element("li");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", {});
      var li_nodes = children(li);
      if (default_slot) default_slot.l(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(li, file5, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      if (default_slot) {
        default_slot.m(li, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DefaultListItem", slots, ["default"]);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<DefaultListItem> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var DefaultListItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DefaultListItem",
      options,
      id: create_fragment5.name
    });
  }
};
var DefaultListItem_default = DefaultListItem;

// node_modules/@portabletext/svelte/dist/defaultComponents/DefaultHardBreak.svelte
var file6 = "node_modules/@portabletext/svelte/dist/defaultComponents/DefaultHardBreak.svelte";
function create_fragment6(ctx) {
  let br;
  const block = {
    c: function create() {
      br = element("br");
      this.h();
    },
    l: function claim(nodes) {
      br = claim_element(nodes, "BR", {});
      this.h();
    },
    h: function hydrate() {
      add_location(br, file6, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, br, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(br);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DefaultHardBreak", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<DefaultHardBreak> was created with unknown prop '${key}'`);
  });
  return [];
}
var DefaultHardBreak = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DefaultHardBreak",
      options,
      id: create_fragment6.name
    });
  }
};
var DefaultHardBreak_default = DefaultHardBreak;

// node_modules/@portabletext/svelte/dist/defaultComponents/UnknownType.svelte
function create_fragment7(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UnknownType", slots, ["default"]);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<UnknownType> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var UnknownType = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UnknownType",
      options,
      id: create_fragment7.name
    });
  }
};
var UnknownType_default = UnknownType;

// node_modules/@portabletext/svelte/dist/defaultComponents/defaultComponents.js
var defaultComponents = {
  marks: {
    "strike-through": DefaultMark_default,
    code: DefaultMark_default,
    em: DefaultMark_default,
    strong: DefaultMark_default,
    underline: DefaultMark_default,
    link: DefaultLink_default
  },
  block: {
    blockquote: DefaultBlock_default,
    h1: DefaultBlock_default,
    h2: DefaultBlock_default,
    h3: DefaultBlock_default,
    h4: DefaultBlock_default,
    h5: DefaultBlock_default,
    h6: DefaultBlock_default,
    normal: DefaultBlock_default
  },
  list: {
    bullet: DefaultList_default,
    number: DefaultList_default
  },
  listItem: {
    bullet: DefaultListItem_default,
    number: DefaultListItem_default
  },
  types: {},
  hardBreak: DefaultHardBreak_default,
  unknownBlockStyle: DefaultBlock_default,
  unknownList: DefaultList_default,
  unknownListItem: DefaultListItem_default,
  unknownMark: DefaultMark_default,
  unknownType: UnknownType_default
};
var defaultComponents_default = defaultComponents;

// node_modules/@portabletext/svelte/dist/defaultComponents/mergeComponents.js
function mergeComponents(parent, overrides = {}) {
  return {
    ...parent,
    ...overrides,
    block: mergeDeeply(parent, overrides, "block"),
    list: mergeDeeply(parent, overrides, "list"),
    listItem: mergeDeeply(parent, overrides, "listItem"),
    marks: mergeDeeply(parent, overrides, "marks"),
    types: mergeDeeply(parent, overrides, "types")
  };
}
function mergeDeeply(parent, overrides, key) {
  const override = overrides[key];
  const parentVal = parent[key];
  if (typeof override === "function") {
    return override;
  }
  if (override && typeof parentVal === "function") {
    return override;
  }
  if (override) {
    return { ...parentVal, ...override };
  }
  return parentVal;
}

// node_modules/@portabletext/svelte/dist/renderers/RenderBlock.svelte
function create_default_slot(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(24:0) <svelte:component this={blockComponent || components.unknownBlockStyle} portableText={blockProps}>",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*blockComponent*/
    ctx[0] || /*components*/
    ctx[1].unknownBlockStyle
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        portableText: (
          /*blockProps*/
          ctx2[2]
        ),
        $$slots: { default: [create_default_slot] },
        $$scope: { ctx: ctx2 }
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*blockComponent, components*/
      3 && switch_value !== (switch_value = /*blockComponent*/
      ctx2[0] || /*components*/
      ctx2[1].unknownBlockStyle)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*blockProps*/
        4) switch_instance_changes.portableText = /*blockProps*/
        ctx2[2];
        if (dirty & /*$$scope*/
        256) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  let components;
  let style;
  let blockComponent;
  let blockProps;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RenderBlock", slots, ["default"]);
  let { global } = $$props;
  let { node } = $$props;
  let { indexInParent } = $$props;
  $$self.$$.on_mount.push(function() {
    if (global === void 0 && !("global" in $$props || $$self.$$.bound[$$self.$$.props["global"]])) {
      console.warn("<RenderBlock> was created without expected prop 'global'");
    }
    if (node === void 0 && !("node" in $$props || $$self.$$.bound[$$self.$$.props["node"]])) {
      console.warn("<RenderBlock> was created without expected prop 'node'");
    }
    if (indexInParent === void 0 && !("indexInParent" in $$props || $$self.$$.bound[$$self.$$.props["indexInParent"]])) {
      console.warn("<RenderBlock> was created without expected prop 'indexInParent'");
    }
  });
  const writable_props = ["global", "node", "indexInParent"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<RenderBlock> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("global" in $$props2) $$invalidate(3, global = $$props2.global);
    if ("node" in $$props2) $$invalidate(4, node = $$props2.node);
    if ("indexInParent" in $$props2) $$invalidate(5, indexInParent = $$props2.indexInParent);
    if ("$$scope" in $$props2) $$invalidate(8, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    global,
    node,
    indexInParent,
    blockProps,
    style,
    blockComponent,
    components
  });
  $$self.$inject_state = ($$props2) => {
    if ("global" in $$props2) $$invalidate(3, global = $$props2.global);
    if ("node" in $$props2) $$invalidate(4, node = $$props2.node);
    if ("indexInParent" in $$props2) $$invalidate(5, indexInParent = $$props2.indexInParent);
    if ("blockProps" in $$props2) $$invalidate(2, blockProps = $$props2.blockProps);
    if ("style" in $$props2) $$invalidate(6, style = $$props2.style);
    if ("blockComponent" in $$props2) $$invalidate(0, blockComponent = $$props2.blockComponent);
    if ("components" in $$props2) $$invalidate(1, components = $$props2.components);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*global*/
    8) {
      $: $$invalidate(1, { components } = global, components);
    }
    if ($$self.$$.dirty & /*node*/
    16) {
      $: $$invalidate(6, { style = "normal" } = node, style);
    }
    if ($$self.$$.dirty & /*components, style*/
    66) {
      $: $$invalidate(0, blockComponent = typeof components.block === "function" ? components.block : components.block[style]);
    }
    if ($$self.$$.dirty & /*blockComponent, global, style*/
    73) {
      $: if (!blockComponent) {
        global.missingComponentHandler(style, "blockStyle");
      }
    }
    if ($$self.$$.dirty & /*global, indexInParent, node*/
    56) {
      $: $$invalidate(2, blockProps = /* @__PURE__ */ (() => {
        return { global, indexInParent, value: node };
      })());
    }
  };
  return [
    blockComponent,
    components,
    blockProps,
    global,
    node,
    indexInParent,
    style,
    slots,
    $$scope
  ];
}
var RenderBlock = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, { global: 3, node: 4, indexInParent: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RenderBlock",
      options,
      id: create_fragment8.name
    });
  }
  get global() {
    throw new Error("<RenderBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set global(value) {
    throw new Error("<RenderBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get node() {
    throw new Error("<RenderBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set node(value) {
    throw new Error("<RenderBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get indexInParent() {
    throw new Error("<RenderBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set indexInParent(value) {
    throw new Error("<RenderBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RenderBlock_default = RenderBlock;

// node_modules/@portabletext/svelte/dist/renderers/RenderCustomBlock.svelte
function create_fragment9(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*customComponent*/
    ctx[0] || /*components*/
    ctx[1].unknownType
  );
  function switch_props(ctx2, dirty) {
    return {
      props: { portableText: (
        /*componentProps*/
        ctx2[2]
      ) },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*customComponent, components*/
      3 && switch_value !== (switch_value = /*customComponent*/
      ctx2[0] || /*components*/
      ctx2[1].unknownType)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*componentProps*/
        4) switch_instance_changes.portableText = /*componentProps*/
        ctx2[2];
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let components;
  let _type;
  let customComponent;
  let componentProps;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RenderCustomBlock", slots, []);
  let { global } = $$props;
  let { node } = $$props;
  let { parentBlock } = $$props;
  let { indexInParent } = $$props;
  let { isInline = false } = $$props;
  $$self.$$.on_mount.push(function() {
    if (global === void 0 && !("global" in $$props || $$self.$$.bound[$$self.$$.props["global"]])) {
      console.warn("<RenderCustomBlock> was created without expected prop 'global'");
    }
    if (node === void 0 && !("node" in $$props || $$self.$$.bound[$$self.$$.props["node"]])) {
      console.warn("<RenderCustomBlock> was created without expected prop 'node'");
    }
    if (parentBlock === void 0 && !("parentBlock" in $$props || $$self.$$.bound[$$self.$$.props["parentBlock"]])) {
      console.warn("<RenderCustomBlock> was created without expected prop 'parentBlock'");
    }
    if (indexInParent === void 0 && !("indexInParent" in $$props || $$self.$$.bound[$$self.$$.props["indexInParent"]])) {
      console.warn("<RenderCustomBlock> was created without expected prop 'indexInParent'");
    }
  });
  const writable_props = ["global", "node", "parentBlock", "indexInParent", "isInline"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<RenderCustomBlock> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("global" in $$props2) $$invalidate(3, global = $$props2.global);
    if ("node" in $$props2) $$invalidate(4, node = $$props2.node);
    if ("parentBlock" in $$props2) $$invalidate(5, parentBlock = $$props2.parentBlock);
    if ("indexInParent" in $$props2) $$invalidate(6, indexInParent = $$props2.indexInParent);
    if ("isInline" in $$props2) $$invalidate(7, isInline = $$props2.isInline);
  };
  $$self.$capture_state = () => ({
    global,
    node,
    parentBlock,
    indexInParent,
    isInline,
    componentProps,
    _type,
    customComponent,
    components
  });
  $$self.$inject_state = ($$props2) => {
    if ("global" in $$props2) $$invalidate(3, global = $$props2.global);
    if ("node" in $$props2) $$invalidate(4, node = $$props2.node);
    if ("parentBlock" in $$props2) $$invalidate(5, parentBlock = $$props2.parentBlock);
    if ("indexInParent" in $$props2) $$invalidate(6, indexInParent = $$props2.indexInParent);
    if ("isInline" in $$props2) $$invalidate(7, isInline = $$props2.isInline);
    if ("componentProps" in $$props2) $$invalidate(2, componentProps = $$props2.componentProps);
    if ("_type" in $$props2) $$invalidate(8, _type = $$props2._type);
    if ("customComponent" in $$props2) $$invalidate(0, customComponent = $$props2.customComponent);
    if ("components" in $$props2) $$invalidate(1, components = $$props2.components);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*global*/
    8) {
      $: $$invalidate(1, { components } = global, components);
    }
    if ($$self.$$.dirty & /*node*/
    16) {
      $: $$invalidate(8, { _type } = node, _type);
    }
    if ($$self.$$.dirty & /*components, _type*/
    258) {
      $: $$invalidate(0, customComponent = components.types[_type]);
    }
    if ($$self.$$.dirty & /*customComponent, global, _type*/
    265) {
      $: if (!customComponent) {
        global.missingComponentHandler(_type, "block");
      }
    }
    if ($$self.$$.dirty & /*global, node, indexInParent, parentBlock, isInline*/
    248) {
      $: $$invalidate(2, componentProps = /* @__PURE__ */ (() => {
        return {
          global,
          value: node,
          indexInParent,
          parentBlock,
          isInline
        };
      })());
    }
  };
  return [
    customComponent,
    components,
    componentProps,
    global,
    node,
    parentBlock,
    indexInParent,
    isInline,
    _type
  ];
}
var RenderCustomBlock = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, {
      global: 3,
      node: 4,
      parentBlock: 5,
      indexInParent: 6,
      isInline: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RenderCustomBlock",
      options,
      id: create_fragment9.name
    });
  }
  get global() {
    throw new Error("<RenderCustomBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set global(value) {
    throw new Error("<RenderCustomBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get node() {
    throw new Error("<RenderCustomBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set node(value) {
    throw new Error("<RenderCustomBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get parentBlock() {
    throw new Error("<RenderCustomBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set parentBlock(value) {
    throw new Error("<RenderCustomBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get indexInParent() {
    throw new Error("<RenderCustomBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set indexInParent(value) {
    throw new Error("<RenderCustomBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isInline() {
    throw new Error("<RenderCustomBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isInline(value) {
    throw new Error("<RenderCustomBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RenderCustomBlock_default = RenderCustomBlock;

// node_modules/@portabletext/svelte/dist/renderers/RenderList.svelte
function create_default_slot2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(26:0) <svelte:component this={listComponent || components.unknownList} portableText={listProps}>",
    ctx
  });
  return block;
}
function create_fragment10(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*listComponent*/
    ctx[0] || /*components*/
    ctx[1].unknownList
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        portableText: (
          /*listProps*/
          ctx2[2]
        ),
        $$slots: { default: [create_default_slot2] },
        $$scope: { ctx: ctx2 }
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*listComponent, components*/
      3 && switch_value !== (switch_value = /*listComponent*/
      ctx2[0] || /*components*/
      ctx2[1].unknownList)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*listProps*/
        4) switch_instance_changes.portableText = /*listProps*/
        ctx2[2];
        if (dirty & /*$$scope*/
        512) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  let components;
  let listItem;
  let handler;
  let listComponent;
  let listProps;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RenderList", slots, ["default"]);
  let { global } = $$props;
  let { indexInParent } = $$props;
  let { node } = $$props;
  $$self.$$.on_mount.push(function() {
    if (global === void 0 && !("global" in $$props || $$self.$$.bound[$$self.$$.props["global"]])) {
      console.warn("<RenderList> was created without expected prop 'global'");
    }
    if (indexInParent === void 0 && !("indexInParent" in $$props || $$self.$$.bound[$$self.$$.props["indexInParent"]])) {
      console.warn("<RenderList> was created without expected prop 'indexInParent'");
    }
    if (node === void 0 && !("node" in $$props || $$self.$$.bound[$$self.$$.props["node"]])) {
      console.warn("<RenderList> was created without expected prop 'node'");
    }
  });
  const writable_props = ["global", "indexInParent", "node"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<RenderList> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("global" in $$props2) $$invalidate(3, global = $$props2.global);
    if ("indexInParent" in $$props2) $$invalidate(4, indexInParent = $$props2.indexInParent);
    if ("node" in $$props2) $$invalidate(5, node = $$props2.node);
    if ("$$scope" in $$props2) $$invalidate(9, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    global,
    indexInParent,
    node,
    listProps,
    listItem,
    listComponent,
    handler,
    components
  });
  $$self.$inject_state = ($$props2) => {
    if ("global" in $$props2) $$invalidate(3, global = $$props2.global);
    if ("indexInParent" in $$props2) $$invalidate(4, indexInParent = $$props2.indexInParent);
    if ("node" in $$props2) $$invalidate(5, node = $$props2.node);
    if ("listProps" in $$props2) $$invalidate(2, listProps = $$props2.listProps);
    if ("listItem" in $$props2) $$invalidate(6, listItem = $$props2.listItem);
    if ("listComponent" in $$props2) $$invalidate(0, listComponent = $$props2.listComponent);
    if ("handler" in $$props2) $$invalidate(7, handler = $$props2.handler);
    if ("components" in $$props2) $$invalidate(1, components = $$props2.components);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*global*/
    8) {
      $: $$invalidate(1, { components } = global, components);
    }
    if ($$self.$$.dirty & /*node*/
    32) {
      $: $$invalidate(6, { listItem } = node, listItem);
    }
    if ($$self.$$.dirty & /*components, listItem*/
    66) {
      $: $$invalidate(7, handler = typeof components.list === "function" ? components.list : components.list[listItem]);
    }
    if ($$self.$$.dirty & /*handler*/
    128) {
      $: $$invalidate(0, listComponent = handler);
    }
    if ($$self.$$.dirty & /*listComponent, global, listItem*/
    73) {
      $: if (!listComponent) {
        global.missingComponentHandler(listItem, "listStyle");
      }
    }
    if ($$self.$$.dirty & /*global, node, indexInParent*/
    56) {
      $: $$invalidate(2, listProps = /* @__PURE__ */ (() => {
        return { global, value: node, indexInParent };
      })());
    }
  };
  return [
    listComponent,
    components,
    listProps,
    global,
    indexInParent,
    node,
    listItem,
    handler,
    slots,
    $$scope
  ];
}
var RenderList = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, { global: 3, indexInParent: 4, node: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RenderList",
      options,
      id: create_fragment10.name
    });
  }
  get global() {
    throw new Error("<RenderList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set global(value) {
    throw new Error("<RenderList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get indexInParent() {
    throw new Error("<RenderList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set indexInParent(value) {
    throw new Error("<RenderList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get node() {
    throw new Error("<RenderList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set node(value) {
    throw new Error("<RenderList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RenderList_default = RenderList;

// node_modules/@portabletext/svelte/dist/renderers/RenderListItem.svelte
function create_else_block5(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block5.name,
    type: "else",
    source: "(45:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block5(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*styleComponent*/
    ctx[4]
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        portableText: {
          // Different props for the block that will hold this list
          .../*listItemProps*/
          ctx2[3],
          value: {
            .../*node*/
            ctx2[0],
            // BlockComponentProps shouldn't receive a listItem
            listItem: void 0
          }
        },
        $$slots: { default: [create_default_slot_1] },
        $$scope: { ctx: ctx2 }
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*styleComponent*/
      16 && switch_value !== (switch_value = /*styleComponent*/
      ctx2[4])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*listItemProps, node*/
        9) switch_instance_changes.portableText = {
          // Different props for the block that will hold this list
          .../*listItemProps*/
          ctx2[3],
          value: {
            .../*node*/
            ctx2[0],
            // BlockComponentProps shouldn't receive a listItem
            listItem: void 0
          }
        };
        if (dirty & /*$$scope*/
        512) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(30:2) {#if styleComponent}",
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(31:4) <svelte:component       this={styleComponent}       portableText={{         // Different props for the block that will hold this list         ...listItemProps,         value: {           ...node,           // BlockComponentProps shouldn't receive a listItem           listItem: undefined         }       }}     >",
    ctx
  });
  return block;
}
function create_default_slot3(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block5, create_else_block5];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*styleComponent*/
      ctx2[4]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: "(26:0) <svelte:component   this={listItemComponent || components.unknownListItem}   portableText={listItemProps} >",
    ctx
  });
  return block;
}
function create_fragment11(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*listItemComponent*/
    ctx[2] || /*components*/
    ctx[1].unknownListItem
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        portableText: (
          /*listItemProps*/
          ctx2[3]
        ),
        $$slots: { default: [create_default_slot3] },
        $$scope: { ctx: ctx2 }
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*listItemComponent, components*/
      6 && switch_value !== (switch_value = /*listItemComponent*/
      ctx2[2] || /*components*/
      ctx2[1].unknownListItem)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*listItemProps*/
        8) switch_instance_changes.portableText = /*listItemProps*/
        ctx2[3];
        if (dirty & /*$$scope, styleComponent, listItemProps, node*/
        537) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  let components;
  let style;
  let listItemComponent;
  let styleComponent;
  let listItemProps;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RenderListItem", slots, ["default"]);
  let { global } = $$props;
  let { indexInParent } = $$props;
  let { node } = $$props;
  $$self.$$.on_mount.push(function() {
    if (global === void 0 && !("global" in $$props || $$self.$$.bound[$$self.$$.props["global"]])) {
      console.warn("<RenderListItem> was created without expected prop 'global'");
    }
    if (indexInParent === void 0 && !("indexInParent" in $$props || $$self.$$.bound[$$self.$$.props["indexInParent"]])) {
      console.warn("<RenderListItem> was created without expected prop 'indexInParent'");
    }
    if (node === void 0 && !("node" in $$props || $$self.$$.bound[$$self.$$.props["node"]])) {
      console.warn("<RenderListItem> was created without expected prop 'node'");
    }
  });
  const writable_props = ["global", "indexInParent", "node"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<RenderListItem> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("global" in $$props2) $$invalidate(5, global = $$props2.global);
    if ("indexInParent" in $$props2) $$invalidate(6, indexInParent = $$props2.indexInParent);
    if ("node" in $$props2) $$invalidate(0, node = $$props2.node);
    if ("$$scope" in $$props2) $$invalidate(9, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    global,
    indexInParent,
    node,
    listItemProps,
    style,
    components,
    styleComponent,
    listItemComponent
  });
  $$self.$inject_state = ($$props2) => {
    if ("global" in $$props2) $$invalidate(5, global = $$props2.global);
    if ("indexInParent" in $$props2) $$invalidate(6, indexInParent = $$props2.indexInParent);
    if ("node" in $$props2) $$invalidate(0, node = $$props2.node);
    if ("listItemProps" in $$props2) $$invalidate(3, listItemProps = $$props2.listItemProps);
    if ("style" in $$props2) $$invalidate(7, style = $$props2.style);
    if ("components" in $$props2) $$invalidate(1, components = $$props2.components);
    if ("styleComponent" in $$props2) $$invalidate(4, styleComponent = $$props2.styleComponent);
    if ("listItemComponent" in $$props2) $$invalidate(2, listItemComponent = $$props2.listItemComponent);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*global*/
    32) {
      $: $$invalidate(1, { components } = global, components);
    }
    if ($$self.$$.dirty & /*node*/
    1) {
      $: $$invalidate(7, { style = "normal" } = node, style);
    }
    if ($$self.$$.dirty & /*components, style*/
    130) {
      $: $$invalidate(2, listItemComponent = typeof components.listItem === "function" ? components.listItem : components.listItem[style]);
    }
    if ($$self.$$.dirty & /*listItemComponent, global, style*/
    164) {
      $: if (!listItemComponent) {
        global.missingComponentHandler(style, "listItemStyle");
      }
    }
    if ($$self.$$.dirty & /*style, components*/
    130) {
      $: $$invalidate(4, styleComponent = style !== "normal" ? components.block[style] : void 0);
    }
    if ($$self.$$.dirty & /*global, node, indexInParent*/
    97) {
      $: $$invalidate(3, listItemProps = /* @__PURE__ */ (() => {
        return { global, value: node, indexInParent };
      })());
    }
  };
  return [
    node,
    components,
    listItemComponent,
    listItemProps,
    styleComponent,
    global,
    indexInParent,
    style,
    slots,
    $$scope
  ];
}
var RenderListItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, { global: 5, indexInParent: 6, node: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RenderListItem",
      options,
      id: create_fragment11.name
    });
  }
  get global() {
    throw new Error("<RenderListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set global(value) {
    throw new Error("<RenderListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get indexInParent() {
    throw new Error("<RenderListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set indexInParent(value) {
    throw new Error("<RenderListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get node() {
    throw new Error("<RenderListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set node(value) {
    throw new Error("<RenderListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RenderListItem_default = RenderListItem;

// node_modules/@portabletext/svelte/dist/renderers/RenderSpan.svelte
function create_default_slot4(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot4.name,
    type: "slot",
    source: "(28:0) <svelte:component this={markComponent || components.unknownMark} portableText={markProps}>",
    ctx
  });
  return block;
}
function create_fragment12(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*markComponent*/
    ctx[0] || /*components*/
    ctx[1].unknownMark
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        portableText: (
          /*markProps*/
          ctx2[2]
        ),
        $$slots: { default: [create_default_slot4] },
        $$scope: { ctx: ctx2 }
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*markComponent, components*/
      3 && switch_value !== (switch_value = /*markComponent*/
      ctx2[0] || /*components*/
      ctx2[1].unknownMark)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*markProps*/
        4) switch_instance_changes.portableText = /*markProps*/
        ctx2[2];
        if (dirty & /*$$scope*/
        256) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance12($$self, $$props, $$invalidate) {
  let components;
  let markType;
  let markComponent;
  let markProps;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RenderSpan", slots, ["default"]);
  let { global } = $$props;
  let { node } = $$props;
  let { parentBlock } = $$props;
  $$self.$$.on_mount.push(function() {
    if (global === void 0 && !("global" in $$props || $$self.$$.bound[$$self.$$.props["global"]])) {
      console.warn("<RenderSpan> was created without expected prop 'global'");
    }
    if (node === void 0 && !("node" in $$props || $$self.$$.bound[$$self.$$.props["node"]])) {
      console.warn("<RenderSpan> was created without expected prop 'node'");
    }
    if (parentBlock === void 0 && !("parentBlock" in $$props || $$self.$$.bound[$$self.$$.props["parentBlock"]])) {
      console.warn("<RenderSpan> was created without expected prop 'parentBlock'");
    }
  });
  const writable_props = ["global", "node", "parentBlock"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<RenderSpan> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("global" in $$props2) $$invalidate(3, global = $$props2.global);
    if ("node" in $$props2) $$invalidate(4, node = $$props2.node);
    if ("parentBlock" in $$props2) $$invalidate(5, parentBlock = $$props2.parentBlock);
    if ("$$scope" in $$props2) $$invalidate(8, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    spanToPlainText,
    global,
    node,
    parentBlock,
    markType,
    markProps,
    markComponent,
    components
  });
  $$self.$inject_state = ($$props2) => {
    if ("global" in $$props2) $$invalidate(3, global = $$props2.global);
    if ("node" in $$props2) $$invalidate(4, node = $$props2.node);
    if ("parentBlock" in $$props2) $$invalidate(5, parentBlock = $$props2.parentBlock);
    if ("markType" in $$props2) $$invalidate(6, markType = $$props2.markType);
    if ("markProps" in $$props2) $$invalidate(2, markProps = $$props2.markProps);
    if ("markComponent" in $$props2) $$invalidate(0, markComponent = $$props2.markComponent);
    if ("components" in $$props2) $$invalidate(1, components = $$props2.components);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*global*/
    8) {
      $: $$invalidate(1, { components } = global, components);
    }
    if ($$self.$$.dirty & /*node*/
    16) {
      $: $$invalidate(6, { markType } = node, markType);
    }
    if ($$self.$$.dirty & /*components, markType*/
    66) {
      $: $$invalidate(0, markComponent = components.marks[markType]);
    }
    if ($$self.$$.dirty & /*markComponent, global, markType*/
    73) {
      $: if (!markComponent) {
        global.missingComponentHandler(markType, "mark");
      }
    }
    if ($$self.$$.dirty & /*global, parentBlock, markType, node*/
    120) {
      $: $$invalidate(2, markProps = (() => {
        return {
          global,
          parentBlock,
          markType,
          value: node.markDef,
          markKey: node.markKey,
          plainTextContent: spanToPlainText(node)
        };
      })());
    }
  };
  return [
    markComponent,
    components,
    markProps,
    global,
    node,
    parentBlock,
    markType,
    slots,
    $$scope
  ];
}
var RenderSpan = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, { global: 3, node: 4, parentBlock: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RenderSpan",
      options,
      id: create_fragment12.name
    });
  }
  get global() {
    throw new Error("<RenderSpan>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set global(value) {
    throw new Error("<RenderSpan>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get node() {
    throw new Error("<RenderSpan>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set node(value) {
    throw new Error("<RenderSpan>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get parentBlock() {
    throw new Error("<RenderSpan>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set parentBlock(value) {
    throw new Error("<RenderSpan>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RenderSpan_default = RenderSpan;

// node_modules/@portabletext/svelte/dist/renderers/RenderText.svelte
function create_else_block_1(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*text*/
        ctx[0]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*text*/
        ctx[0]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*text*/
      1) set_data_dev(
        t,
        /*text*/
        ctx2[0]
      );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_1.name,
    type: "else",
    source: "(15:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block6(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_13, create_else_block6];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (typeof /*components*/
    ctx2[1].hardBreak === "function") return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block6.name,
    type: "if",
    source: "(9:0) {#if text === '\\n'}",
    ctx
  });
  return block;
}
function create_else_block6(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*text*/
        ctx[0]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*text*/
        ctx[0]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*text*/
      1) set_data_dev(
        t,
        /*text*/
        ctx2[0]
      );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block6.name,
    type: "else",
    source: "(12:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_13(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*components*/
    ctx[1].hardBreak
  );
  function switch_props(ctx2, dirty) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*components*/
      2 && switch_value !== (switch_value = /*components*/
      ctx2[1].hardBreak)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_13.name,
    type: "if",
    source: "(10:2) {#if typeof components.hardBreak === 'function'}",
    ctx
  });
  return block;
}
function create_fragment13(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block6, create_else_block_1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*text*/
      ctx2[0] === "\n"
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  let components;
  let text2;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RenderText", slots, []);
  let { global } = $$props;
  let { node } = $$props;
  $$self.$$.on_mount.push(function() {
    if (global === void 0 && !("global" in $$props || $$self.$$.bound[$$self.$$.props["global"]])) {
      console.warn("<RenderText> was created without expected prop 'global'");
    }
    if (node === void 0 && !("node" in $$props || $$self.$$.bound[$$self.$$.props["node"]])) {
      console.warn("<RenderText> was created without expected prop 'node'");
    }
  });
  const writable_props = ["global", "node"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<RenderText> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("global" in $$props2) $$invalidate(2, global = $$props2.global);
    if ("node" in $$props2) $$invalidate(3, node = $$props2.node);
  };
  $$self.$capture_state = () => ({ global, node, text: text2, components });
  $$self.$inject_state = ($$props2) => {
    if ("global" in $$props2) $$invalidate(2, global = $$props2.global);
    if ("node" in $$props2) $$invalidate(3, node = $$props2.node);
    if ("text" in $$props2) $$invalidate(0, text2 = $$props2.text);
    if ("components" in $$props2) $$invalidate(1, components = $$props2.components);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*global*/
    4) {
      $: $$invalidate(1, { components } = global, components);
    }
    if ($$self.$$.dirty & /*node*/
    8) {
      $: $$invalidate(0, { text: text2 } = node, text2);
    }
  };
  return [text2, components, global, node];
}
var RenderText = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, { global: 2, node: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RenderText",
      options,
      id: create_fragment13.name
    });
  }
  get global() {
    throw new Error("<RenderText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set global(value) {
    throw new Error("<RenderText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get node() {
    throw new Error("<RenderText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set node(value) {
    throw new Error("<RenderText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RenderText_default = RenderText;

// node_modules/@portabletext/svelte/dist/RenderNode.svelte
function get_each_context_3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  child_ctx[8] = i;
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  child_ctx[8] = i;
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  child_ctx[8] = i;
  return child_ctx;
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  child_ctx[8] = i;
  return child_ctx;
}
function create_if_block_5(ctx) {
  let rendercustomblock;
  let current;
  rendercustomblock = new RenderCustomBlock_default({
    props: {
      node: (
        /*node*/
        ctx[4]
      ),
      parentBlock: (
        /*parentBlock*/
        ctx[2]
      ),
      indexInParent: (
        /*indexInParent*/
        ctx[3]
      ),
      isInline: (
        /*isInline*/
        ctx[1]
      ),
      global: (
        /*global*/
        ctx[0]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(rendercustomblock.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(rendercustomblock.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(rendercustomblock, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const rendercustomblock_changes = {};
      if (dirty & /*node*/
      16) rendercustomblock_changes.node = /*node*/
      ctx2[4];
      if (dirty & /*parentBlock*/
      4) rendercustomblock_changes.parentBlock = /*parentBlock*/
      ctx2[2];
      if (dirty & /*indexInParent*/
      8) rendercustomblock_changes.indexInParent = /*indexInParent*/
      ctx2[3];
      if (dirty & /*isInline*/
      2) rendercustomblock_changes.isInline = /*isInline*/
      ctx2[1];
      if (dirty & /*global*/
      1) rendercustomblock_changes.global = /*global*/
      ctx2[0];
      rendercustomblock.$set(rendercustomblock_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(rendercustomblock.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(rendercustomblock.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(rendercustomblock, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(81:15) ",
    ctx
  });
  return block;
}
function create_if_block_42(ctx) {
  let rendertext;
  let current;
  rendertext = new RenderText_default({
    props: {
      node: (
        /*node*/
        ctx[4]
      ),
      global: (
        /*global*/
        ctx[0]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(rendertext.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(rendertext.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(rendertext, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const rendertext_changes = {};
      if (dirty & /*node*/
      16) rendertext_changes.node = /*node*/
      ctx2[4];
      if (dirty & /*global*/
      1) rendertext_changes.global = /*global*/
      ctx2[0];
      rendertext.$set(rendertext_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(rendertext.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(rendertext.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(rendertext, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_42.name,
    type: "if",
    source: "(79:46) ",
    ctx
  });
  return block;
}
function create_if_block_32(ctx) {
  let renderblock;
  let current;
  renderblock = new RenderBlock_default({
    props: {
      node: (
        /*node*/
        ctx[4]
      ),
      indexInParent: (
        /*indexInParent*/
        ctx[3]
      ),
      global: (
        /*global*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(renderblock.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(renderblock.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(renderblock, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const renderblock_changes = {};
      if (dirty & /*node*/
      16) renderblock_changes.node = /*node*/
      ctx2[4];
      if (dirty & /*indexInParent*/
      8) renderblock_changes.indexInParent = /*indexInParent*/
      ctx2[3];
      if (dirty & /*global*/
      1) renderblock_changes.global = /*global*/
      ctx2[0];
      if (dirty & /*$$scope, node, global*/
      4113) {
        renderblock_changes.$$scope = { dirty, ctx: ctx2 };
      }
      renderblock.$set(renderblock_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(renderblock.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(renderblock.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(renderblock, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_32.name,
    type: "if",
    source: "(65:36) ",
    ctx
  });
  return block;
}
function create_if_block_22(ctx) {
  let renderspan;
  let current;
  renderspan = new RenderSpan_default({
    props: {
      node: (
        /*node*/
        ctx[4]
      ),
      parentBlock: (
        /*parentBlock*/
        ctx[2]
      ),
      global: (
        /*global*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(renderspan.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(renderspan.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(renderspan, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const renderspan_changes = {};
      if (dirty & /*node*/
      16) renderspan_changes.node = /*node*/
      ctx2[4];
      if (dirty & /*parentBlock*/
      4) renderspan_changes.parentBlock = /*parentBlock*/
      ctx2[2];
      if (dirty & /*global*/
      1) renderspan_changes.global = /*global*/
      ctx2[0];
      if (dirty & /*$$scope, node, parentBlock, global*/
      4117) {
        renderspan_changes.$$scope = { dirty, ctx: ctx2 };
      }
      renderspan.$set(renderspan_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(renderspan.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(renderspan.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(renderspan, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_22.name,
    type: "if",
    source: "(51:42) ",
    ctx
  });
  return block;
}
function create_if_block_14(ctx) {
  let renderlistitem;
  let current;
  renderlistitem = new RenderListItem_default({
    props: {
      node: (
        /*node*/
        ctx[4]
      ),
      indexInParent: (
        /*indexInParent*/
        ctx[3]
      ),
      global: (
        /*global*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(renderlistitem.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(renderlistitem.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(renderlistitem, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const renderlistitem_changes = {};
      if (dirty & /*node*/
      16) renderlistitem_changes.node = /*node*/
      ctx2[4];
      if (dirty & /*indexInParent*/
      8) renderlistitem_changes.indexInParent = /*indexInParent*/
      ctx2[3];
      if (dirty & /*global*/
      1) renderlistitem_changes.global = /*global*/
      ctx2[0];
      if (dirty & /*$$scope, node, global*/
      4113) {
        renderlistitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      renderlistitem.$set(renderlistitem_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(renderlistitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(renderlistitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(renderlistitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_14.name,
    type: "if",
    source: "(36:44) ",
    ctx
  });
  return block;
}
function create_if_block7(ctx) {
  let renderlist;
  let current;
  renderlist = new RenderList_default({
    props: {
      node: (
        /*node*/
        ctx[4]
      ),
      indexInParent: (
        /*indexInParent*/
        ctx[3]
      ),
      global: (
        /*global*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(renderlist.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(renderlist.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(renderlist, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const renderlist_changes = {};
      if (dirty & /*node*/
      16) renderlist_changes.node = /*node*/
      ctx2[4];
      if (dirty & /*indexInParent*/
      8) renderlist_changes.indexInParent = /*indexInParent*/
      ctx2[3];
      if (dirty & /*global*/
      1) renderlist_changes.global = /*global*/
      ctx2[0];
      if (dirty & /*$$scope, node, global*/
      4113) {
        renderlist_changes.$$scope = { dirty, ctx: ctx2 };
      }
      renderlist.$set(renderlist_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(renderlist.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(renderlist.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(renderlist, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block7.name,
    type: "if",
    source: "(21:0) {#if isPortableTextToolkitList(node)}",
    ctx
  });
  return block;
}
function create_each_block_3(ctx) {
  let rendernode;
  let current;
  rendernode = new RenderNode({
    props: {
      options: {
        parentBlock: (
          /*node*/
          ctx[4]
        ),
        node: (
          /*child*/
          ctx[6]
        ),
        isInline: true,
        indexInParent: (
          /*childIndex*/
          ctx[8]
        )
      },
      global: (
        /*global*/
        ctx[0]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(rendernode.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(rendernode.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(rendernode, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const rendernode_changes = {};
      if (dirty & /*node*/
      16) rendernode_changes.options = {
        parentBlock: (
          /*node*/
          ctx2[4]
        ),
        node: (
          /*child*/
          ctx2[6]
        ),
        isInline: true,
        indexInParent: (
          /*childIndex*/
          ctx2[8]
        )
      };
      if (dirty & /*global*/
      1) rendernode_changes.global = /*global*/
      ctx2[0];
      rendernode.$set(rendernode_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(rendernode.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(rendernode.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(rendernode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_3.name,
    type: "each",
    source: "(67:4) {#each buildMarksTree(node) as child, childIndex}",
    ctx
  });
  return block;
}
function create_default_slot_3(ctx) {
  let each_1_anchor;
  let current;
  let each_value_3 = ensure_array_like_dev(buildMarksTree(
    /*node*/
    ctx[4]
  ));
  let each_blocks = [];
  for (let i = 0; i < each_value_3.length; i += 1) {
    each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*node, global*/
      17) {
        each_value_3 = ensure_array_like_dev(buildMarksTree(
          /*node*/
          ctx2[4]
        ));
        let i;
        for (i = 0; i < each_value_3.length; i += 1) {
          const child_ctx = get_each_context_3(ctx2, each_value_3, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_3.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value_3.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3.name,
    type: "slot",
    source: "(66:2) <RenderBlock {node} {indexInParent} {global}>",
    ctx
  });
  return block;
}
function create_each_block_2(ctx) {
  let rendernode;
  let current;
  rendernode = new RenderNode({
    props: {
      options: {
        parentBlock: (
          /*parentBlock*/
          ctx[2]
        ),
        node: (
          /*child*/
          ctx[6]
        ),
        isInline: true,
        indexInParent: (
          /*childIndex*/
          ctx[8]
        )
      },
      global: (
        /*global*/
        ctx[0]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(rendernode.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(rendernode.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(rendernode, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const rendernode_changes = {};
      if (dirty & /*parentBlock, node*/
      20) rendernode_changes.options = {
        parentBlock: (
          /*parentBlock*/
          ctx2[2]
        ),
        node: (
          /*child*/
          ctx2[6]
        ),
        isInline: true,
        indexInParent: (
          /*childIndex*/
          ctx2[8]
        )
      };
      if (dirty & /*global*/
      1) rendernode_changes.global = /*global*/
      ctx2[0];
      rendernode.$set(rendernode_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(rendernode.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(rendernode.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(rendernode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_2.name,
    type: "each",
    source: "(53:4) {#each node.children as child, childIndex}",
    ctx
  });
  return block;
}
function create_default_slot_2(ctx) {
  let each_1_anchor;
  let current;
  let each_value_2 = ensure_array_like_dev(
    /*node*/
    ctx[4].children
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*parentBlock, node, global*/
      21) {
        each_value_2 = ensure_array_like_dev(
          /*node*/
          ctx2[4].children
        );
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_2.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value_2.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: "(52:2) <RenderSpan {node} {parentBlock} {global}>",
    ctx
  });
  return block;
}
function create_each_block_1(ctx) {
  let rendernode;
  let current;
  rendernode = new RenderNode({
    props: {
      options: {
        // Pass the current listItem as a parentBlock
        parentBlock: (
          /*node*/
          ctx[4]
        ),
        node: (
          /*child*/
          ctx[6]
        ),
        isInline: true,
        indexInParent: (
          /*childIndex*/
          ctx[8]
        )
      },
      global: (
        /*global*/
        ctx[0]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(rendernode.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(rendernode.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(rendernode, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const rendernode_changes = {};
      if (dirty & /*node*/
      16) rendernode_changes.options = {
        // Pass the current listItem as a parentBlock
        parentBlock: (
          /*node*/
          ctx2[4]
        ),
        node: (
          /*child*/
          ctx2[6]
        ),
        isInline: true,
        indexInParent: (
          /*childIndex*/
          ctx2[8]
        )
      };
      if (dirty & /*global*/
      1) rendernode_changes.global = /*global*/
      ctx2[0];
      rendernode.$set(rendernode_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(rendernode.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(rendernode.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(rendernode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(38:4) {#each buildMarksTree(node) as child, childIndex}",
    ctx
  });
  return block;
}
function create_default_slot_12(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = ensure_array_like_dev(buildMarksTree(
    /*node*/
    ctx[4]
  ));
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*node, global*/
      17) {
        each_value_1 = ensure_array_like_dev(buildMarksTree(
          /*node*/
          ctx2[4]
        ));
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_12.name,
    type: "slot",
    source: "(37:2) <RenderListItem {node} {indexInParent} {global}>",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let rendernode;
  let current;
  rendernode = new RenderNode({
    props: {
      options: {
        node: (
          /*child*/
          ctx[6]
        ),
        indexInParent: (
          /*childIndex*/
          ctx[8]
        ),
        // The list's children will be parsed as PortableTextListItem, which will pass the proper parentBlock & isInline
        parentBlock: void 0,
        isInline: void 0
      },
      global: (
        /*global*/
        ctx[0]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(rendernode.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(rendernode.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(rendernode, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const rendernode_changes = {};
      if (dirty & /*node*/
      16) rendernode_changes.options = {
        node: (
          /*child*/
          ctx2[6]
        ),
        indexInParent: (
          /*childIndex*/
          ctx2[8]
        ),
        // The list's children will be parsed as PortableTextListItem, which will pass the proper parentBlock & isInline
        parentBlock: void 0,
        isInline: void 0
      };
      if (dirty & /*global*/
      1) rendernode_changes.global = /*global*/
      ctx2[0];
      rendernode.$set(rendernode_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(rendernode.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(rendernode.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(rendernode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(23:4) {#each node.children as child, childIndex}",
    ctx
  });
  return block;
}
function create_default_slot5(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*node*/
    ctx[4].children
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*node, undefined, global*/
      17) {
        each_value = ensure_array_like_dev(
          /*node*/
          ctx2[4].children
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot5.name,
    type: "slot",
    source: "(22:2) <RenderList {node} {indexInParent} {global}>",
    ctx
  });
  return block;
}
function create_fragment14(ctx) {
  let show_if;
  let show_if_1;
  let show_if_2;
  let show_if_3;
  let show_if_4;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block7,
    create_if_block_14,
    create_if_block_22,
    create_if_block_32,
    create_if_block_42,
    create_if_block_5
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & /*node*/
    16) show_if = null;
    if (dirty & /*node*/
    16) show_if_1 = null;
    if (dirty & /*node*/
    16) show_if_2 = null;
    if (dirty & /*node*/
    16) show_if_3 = null;
    if (dirty & /*node*/
    16) show_if_4 = null;
    if (show_if == null) show_if = !!isPortableTextToolkitList(
      /*node*/
      ctx2[4]
    );
    if (show_if) return 0;
    if (show_if_1 == null) show_if_1 = !!isPortableTextListItemBlock(
      /*node*/
      ctx2[4]
    );
    if (show_if_1) return 1;
    if (show_if_2 == null) show_if_2 = !!isPortableTextToolkitSpan(
      /*node*/
      ctx2[4]
    );
    if (show_if_2) return 2;
    if (show_if_3 == null) show_if_3 = !!isPortableTextBlock(
      /*node*/
      ctx2[4]
    );
    if (show_if_3) return 3;
    if (show_if_4 == null) show_if_4 = !!isPortableTextToolkitTextNode(
      /*node*/
      ctx2[4]
    );
    if (show_if_4) return 4;
    if (
      /*node*/
      ctx2[4]
    ) return 5;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance14($$self, $$props, $$invalidate) {
  let node;
  let indexInParent;
  let parentBlock;
  let isInline;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RenderNode", slots, []);
  let { global } = $$props;
  let { options } = $$props;
  $$self.$$.on_mount.push(function() {
    if (global === void 0 && !("global" in $$props || $$self.$$.bound[$$self.$$.props["global"]])) {
      console.warn("<RenderNode> was created without expected prop 'global'");
    }
    if (options === void 0 && !("options" in $$props || $$self.$$.bound[$$self.$$.props["options"]])) {
      console.warn("<RenderNode> was created without expected prop 'options'");
    }
  });
  const writable_props = ["global", "options"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<RenderNode> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("global" in $$props2) $$invalidate(0, global = $$props2.global);
    if ("options" in $$props2) $$invalidate(5, options = $$props2.options);
  };
  $$self.$capture_state = () => ({
    buildMarksTree,
    isPortableTextBlock,
    isPortableTextListItemBlock,
    isPortableTextToolkitList,
    isPortableTextToolkitSpan,
    isPortableTextToolkitTextNode,
    RenderBlock: RenderBlock_default,
    RenderCustomBlock: RenderCustomBlock_default,
    RenderList: RenderList_default,
    RenderListItem: RenderListItem_default,
    RenderSpan: RenderSpan_default,
    RenderText: RenderText_default,
    global,
    options,
    isInline,
    parentBlock,
    indexInParent,
    node
  });
  $$self.$inject_state = ($$props2) => {
    if ("global" in $$props2) $$invalidate(0, global = $$props2.global);
    if ("options" in $$props2) $$invalidate(5, options = $$props2.options);
    if ("isInline" in $$props2) $$invalidate(1, isInline = $$props2.isInline);
    if ("parentBlock" in $$props2) $$invalidate(2, parentBlock = $$props2.parentBlock);
    if ("indexInParent" in $$props2) $$invalidate(3, indexInParent = $$props2.indexInParent);
    if ("node" in $$props2) $$invalidate(4, node = $$props2.node);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*options*/
    32) {
      $: $$invalidate(4, { node, indexInParent, parentBlock, isInline } = options, node, ($$invalidate(3, indexInParent), $$invalidate(5, options)), ($$invalidate(2, parentBlock), $$invalidate(5, options)), ($$invalidate(1, isInline), $$invalidate(5, options)));
    }
  };
  return [global, isInline, parentBlock, indexInParent, node, options];
}
var RenderNode = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, { global: 0, options: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RenderNode",
      options,
      id: create_fragment14.name
    });
  }
  get global() {
    throw new Error("<RenderNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set global(value) {
    throw new Error("<RenderNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<RenderNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<RenderNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RenderNode_default = RenderNode;

// node_modules/@portabletext/svelte/dist/warnings.js
var getTemplate = (type, prop) => `Unknown ${type}, specify a component for it in the \`components${prop ? "." : ""}${prop}\` prop`;
var getWarningMessage = (type, nodeType) => {
  switch (nodeType) {
    case "block":
      return getTemplate(`block type "${type}"`, "types");
    case "blockStyle":
      return getTemplate(`block style "${type}"`, "block");
    case "listItemStyle":
      return getTemplate(`list item style "${type}"`, "listItem");
    case "listStyle":
      return getTemplate(`list style "${type}"`, "list");
    case "mark":
      return getTemplate(`mark type "${type}"`, "marks");
    default:
      return getTemplate("type");
  }
};
function printWarning(message) {
  console.warn(message);
}

// node_modules/@portabletext/svelte/dist/PortableText.svelte
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i];
  child_ctx[10] = i;
  return child_ctx;
}
function create_each_block2(key_1, ctx) {
  let first;
  let rendernode;
  let current;
  rendernode = new RenderNode_default({
    props: {
      global: {
        components: (
          /*mergedComponents*/
          ctx[4]
        ),
        missingComponentHandler: (
          /*missingComponentHandler*/
          ctx[2]
        ),
        context: (
          /*context*/
          ctx[1]
        ),
        ptBlocks: (
          /*blocks*/
          ctx[3]
        ),
        ptRawValue: (
          /*value*/
          ctx[0]
        )
      },
      options: {
        node: (
          /*node*/
          ctx[8]
        ),
        isInline: false,
        indexInParent: (
          /*index*/
          ctx[10]
        )
      }
    },
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(rendernode.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      claim_component(rendernode.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      mount_component(rendernode, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const rendernode_changes = {};
      if (dirty & /*mergedComponents, missingComponentHandler, context, blocks, value*/
      31) rendernode_changes.global = {
        components: (
          /*mergedComponents*/
          ctx[4]
        ),
        missingComponentHandler: (
          /*missingComponentHandler*/
          ctx[2]
        ),
        context: (
          /*context*/
          ctx[1]
        ),
        ptBlocks: (
          /*blocks*/
          ctx[3]
        ),
        ptRawValue: (
          /*value*/
          ctx[0]
        )
      };
      if (dirty & /*blocks*/
      8) rendernode_changes.options = {
        node: (
          /*node*/
          ctx[8]
        ),
        isInline: false,
        indexInParent: (
          /*index*/
          ctx[10]
        )
      };
      rendernode.$set(rendernode_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(rendernode.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(rendernode.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(rendernode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(31:0) {#each blocks as node, index (node._key)}",
    ctx
  });
  return block;
}
function create_fragment15(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*blocks*/
    ctx[3]
  );
  const get_key = (ctx2) => (
    /*node*/
    ctx2[8]._key
  );
  validate_each_keys(ctx, each_value, get_each_context2, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context2(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block2(key, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*mergedComponents, missingComponentHandler, context, blocks, value*/
      31) {
        each_value = ensure_array_like_dev(
          /*blocks*/
          ctx2[3]
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context2, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block2, each_1_anchor, get_each_context2);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance15($$self, $$props, $$invalidate) {
  let mergedComponents;
  let keyedBlocks;
  let blocks;
  let missingComponentHandler;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PortableText", slots, []);
  let { value = [] } = $$props;
  let { components } = $$props;
  let { context = {} } = $$props;
  let { onMissingComponent = true } = $$props;
  $$self.$$.on_mount.push(function() {
    if (components === void 0 && !("components" in $$props || $$self.$$.bound[$$self.$$.props["components"]])) {
      console.warn("<PortableText> was created without expected prop 'components'");
    }
  });
  const writable_props = ["value", "components", "context", "onMissingComponent"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<PortableText> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2) $$invalidate(0, value = $$props2.value);
    if ("components" in $$props2) $$invalidate(5, components = $$props2.components);
    if ("context" in $$props2) $$invalidate(1, context = $$props2.context);
    if ("onMissingComponent" in $$props2) $$invalidate(6, onMissingComponent = $$props2.onMissingComponent);
  };
  $$self.$capture_state = () => ({
    LIST_NEST_MODE_HTML,
    nestLists,
    assertBlockKey,
    defaultComponents: defaultComponents_default,
    mergeComponents,
    RenderNode: RenderNode_default,
    getWarningMessage,
    printWarning,
    value,
    components,
    context,
    onMissingComponent,
    missingComponentHandler,
    keyedBlocks,
    blocks,
    mergedComponents
  });
  $$self.$inject_state = ($$props2) => {
    if ("value" in $$props2) $$invalidate(0, value = $$props2.value);
    if ("components" in $$props2) $$invalidate(5, components = $$props2.components);
    if ("context" in $$props2) $$invalidate(1, context = $$props2.context);
    if ("onMissingComponent" in $$props2) $$invalidate(6, onMissingComponent = $$props2.onMissingComponent);
    if ("missingComponentHandler" in $$props2) $$invalidate(2, missingComponentHandler = $$props2.missingComponentHandler);
    if ("keyedBlocks" in $$props2) $$invalidate(7, keyedBlocks = $$props2.keyedBlocks);
    if ("blocks" in $$props2) $$invalidate(3, blocks = $$props2.blocks);
    if ("mergedComponents" in $$props2) $$invalidate(4, mergedComponents = $$props2.mergedComponents);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*components*/
    32) {
      $: $$invalidate(4, mergedComponents = mergeComponents(defaultComponents_default, components));
    }
    if ($$self.$$.dirty & /*value*/
    1) {
      $: $$invalidate(7, keyedBlocks = (Array.isArray(value) ? value : [value]).map(assertBlockKey));
    }
    if ($$self.$$.dirty & /*keyedBlocks*/
    128) {
      $: $$invalidate(3, blocks = nestLists(keyedBlocks, LIST_NEST_MODE_HTML));
    }
    if ($$self.$$.dirty & /*onMissingComponent*/
    64) {
      $: $$invalidate(2, missingComponentHandler = (type, nodeType) => {
        if (onMissingComponent === false) {
          return;
        }
        const message = getWarningMessage(type, nodeType);
        if (typeof onMissingComponent === "function") {
          onMissingComponent(message, { type, nodeType });
          return;
        }
        printWarning(message);
      });
    }
  };
  return [
    value,
    context,
    missingComponentHandler,
    blocks,
    mergedComponents,
    components,
    onMissingComponent,
    keyedBlocks
  ];
}
var PortableText = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance15, create_fragment15, safe_not_equal, {
      value: 0,
      components: 5,
      context: 1,
      onMissingComponent: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PortableText",
      options,
      id: create_fragment15.name
    });
  }
  get value() {
    throw new Error("<PortableText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<PortableText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get components() {
    throw new Error("<PortableText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set components(value) {
    throw new Error("<PortableText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get context() {
    throw new Error("<PortableText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error("<PortableText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMissingComponent() {
    throw new Error("<PortableText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMissingComponent(value) {
    throw new Error("<PortableText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PortableText_default = PortableText;
export {
  DefaultBlock_default as DefaultBlock,
  DefaultList_default as DefaultList,
  DefaultListItem_default as DefaultListItem,
  DefaultMark_default as DefaultMark,
  PortableText_default as PortableText,
  toPlainText
};
//# sourceMappingURL=@portabletext_svelte.js.map
